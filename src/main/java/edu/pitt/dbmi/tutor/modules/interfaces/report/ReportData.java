/**
 * This is the object representation of concepts that are in report
 * Author: Eugene Tseytlin (University of Pittsburgh)
 */

package edu.pitt.dbmi.tutor.modules.interfaces.report;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.awt.Color;
import javax.swing.*;
import javax.swing.Timer;

import edu.pitt.dbmi.tutor.beans.*;
import edu.pitt.dbmi.tutor.messages.Constants;
import edu.pitt.dbmi.tutor.modules.interfaces.ReportConcept;
import edu.pitt.dbmi.tutor.modules.interfaces.ReportInterface;
import static edu.pitt.dbmi.tutor.util.OntologyHelper.*;
import edu.pitt.dbmi.tutor.util.Config;
import edu.pitt.dbmi.tutor.util.Eggs;
import edu.pitt.dbmi.tutor.util.OntologyHelper;
import edu.pitt.dbmi.tutor.util.TextHelper;
import edu.pitt.dbmi.tutor.util.UIHelper;
import edu.pitt.ontology.IClass;
import edu.pitt.ontology.IOntology;
import edu.pitt.terminology.Terminology;
import edu.pitt.terminology.lexicon.Annotation;
import edu.pitt.terminology.lexicon.Concept;
import edu.pitt.terminology.lexicon.Source;
import edu.pitt.terminology.util.TerminologyException;
import edu.pitt.text.tools.NegEx;
import edu.pitt.text.tools.TextTools;
import gov.nih.nlm.nls.nlp.textfeatures.Sentence;
import gov.nih.nlm.nls.nlp.textfeatures.Span;

import java.awt.event.*;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;

/**
 * This class represents information about kb
 */
public class ReportData implements ActionListener, PropertyChangeListener {
	private PropertyChangeSupport pcs;
	private NegEx negex;
	private ReportInterface reportInterface;

	// this is a list of tokens that was parsed in the document
	// private SortedSet<ConceptLabel> tokens;
	private SortedSet<ReportConcept> concepts;
	private Set<ReportConcept> removedConcepts;
	private Set<ReportConcept> negatedConcepts;
	private Comparator<ReportConcept> conceptComparator;
	private Timer syncTimer;
	private List<String> mergedTerms;

	/**
	 * constructor
	 */
	public ReportData(ReportInterface ri) {
		reportInterface = ri;
		pcs = new PropertyChangeSupport(this);

		// pcs.addPropertyChangeListener(ca);

		// init list of tokens sorted by offset
		conceptComparator = new Comparator<ReportConcept>() {
			public int compare(ReportConcept o1, ReportConcept o2) {
				int x = o1.getOffset() - o2.getOffset();
				if (x == 0) {
					return o1.getLength() - o2.getLength();
				}
				return x;
			}
		};

		// init lists
		concepts = new TreeSet<ReportConcept>(conceptComparator) {
			public boolean add(ReportConcept e) {
				// we want to do a replace
				for (ReportConcept i : this) {
					if (i.equals(e)) {
						// put old concep id into new reportconcept
						e.setConceptEntry(i.getConceptEntry());
						e.addLabels(i.getLabels());
						remove(i);
						break;
					}
				}
				return super.add(e);
			}

		};
		removedConcepts = new HashSet<ReportConcept>();
		negatedConcepts = new HashSet<ReportConcept>();

		// init negex
		negex = new NegEx();

		// init sync timer
		syncTimer = new Timer(500, new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				reportInterface.getReportScanner().flushText();
				sync();
			}
		});
		syncTimer.setRepeats(false);

		// initiate merged terms list
		mergedTerms = readMergedTerms();
		// mergedTerms.add("([\\d\\.]+)(mm|cm|nm|km|m)");
	}

	public ReportInterface getReportInterface() {
		return reportInterface;
	}

	// ///////////////////////////////////////////////////////////////////////////////////

	/**
	 * Register recognized noun-phrase
	 * 
	 * @param list
	 *            of keys (ConceptLabel) usually generated by Lexicon
	 * @param list
	 *            for error messages
	 * @return list of ConceptLabels
	 * 
	 *         public Collection<ConceptLabel> processPhrase(List<Concept>
	 *         concepts, List messages) { List labels = new ArrayList();
	 *         for(Concept concept: concepts){ // create new labels ConceptLabel
	 *         lbl = new ConceptLabel(concept);
	 *         lbl.setReportPanel(caseAuthor.getReportPanel());
	 *         lbl.setColor(Color.blue); labels.add(lbl);
	 * 
	 *         // add to tokens tokens.add(lbl); } return labels; }
	 */

	private List<String> readMergedTerms() {
		List<String> lines = new ArrayList<String>();
		try {
			InputStream in = Config.getInputStream(Config.getProperty(reportInterface, "merged.terms"));
			if (in == null)
				return lines;

			BufferedReader reader = new BufferedReader(new InputStreamReader(in));
			for (String line = reader.readLine(); line != null; line = reader.readLine()) {
				line = line.trim();
				if (line.length() > 0 && !line.startsWith("#"))
					lines.add(line);
			}
			reader.close();
			in.close();
		} catch (Exception ex) {
			Config.getLogger().severe(TextHelper.getErrorMessage(ex));
		}
		return lines;
	}

	/**
	 * get report concept that matches the given concept
	 */
	private ReportConcept getReportConcept(Concept c) {
		for (ReportConcept e : concepts) {
			if (c.getCode().endsWith(e.getName())) {
				return e;
			}
		}
		return null;
	}

	/**
	 * Register recognized negations
	 * 
	 * @param NegEx
	 *            object that already parsed a sentence
	 * @return list of ConceptLabels
	 */
	public Collection<ConceptLabel> processNegation(NegEx negex, List messages) {
		if (!negex.isTriggered())
			return Collections.EMPTY_LIST;

		List labels = new ArrayList<ConceptLabel>();

		// IOntology ont = reportInterface.getDomainOntology();

		// create initial list of concepts
		List<ReportConcept> clist = new ArrayList<ReportConcept>();
		for (Concept c : negex.getNegatedConcepts()) {
			clist.add(createReportConcept(c));
		}

		// compact concepts
		processConcepts(clist);
		negatedConcepts.addAll(clist);

		// get negated
		for (Concept concept : negex.getNegations()) {
			// create new labels
			ConceptLabel lbl = new ConceptLabel(concept);
			lbl.setReportPanel(reportInterface);
			lbl.setColor(Color.blue);
			labels.add(lbl);

			// add to tokens
			for (ReportConcept e : clist) {
				// create an absent report concept
				ReportConcept no = new ReportConcept(ConceptEntry.getAbsentConcept(), reportInterface);
				no.addLabel(lbl);

				// now add this report concept as negation
				e.setNegation(no);
			}
		}

		return labels;
	}

	/**
	 * process deletion of concept text
	 * 
	 * @param text
	 */
	public void processDeletion(String text, int offset) {
		// go over all concepts and look at which one might be removed
		Set<ReportConcept> torem = new HashSet<ReportConcept>();
		for (ReportConcept c : concepts) {
			if (c.isInConceptText(offset) || (offset <= c.getOffset() && c.getEndOffset() <= (offset + text.length()))) {
				// remove relevant labels
				for (ConceptLabel l : c.getLabels()) {
					if (l.getText() != null && text.contains(l.getText())) {
						torem.add(c);
					}
				}
			}
		}
		
		// remove concepts that were removed
		concepts.removeAll(torem);

		
		// add to removed
		if (!torem.isEmpty()) {
			// temove labels
			for(ReportConcept c: torem){
				c.removeLabels();
			}
			removedConcepts.addAll(torem);

			// start deletion process
			if (syncTimer.isRunning())
				syncTimer.stop();
			syncTimer.start();
		}
	}

	
	/**
	 * is given concept in range of a given span
	 * 
	 * @param c
	 * @param s
	 * @return
	 */
	private boolean intersects(ReportConcept c, Span span) {
		int s = c.getOffset();
		int e = s + c.getLength();
		return (s >= span.getBeginCharacter() && s < span.getEndCharacter())
				|| (e >= span.getBeginCharacter() && e < span.getEndCharacter());

	}


	/**
	 * Register recognized sentence tokens
	 * 
	 * @param list
	 *            of keys (KeyEntry) usually generated by Lexicon
	 * @param list
	 *            for error messages
	 * @return list of ConceptLabels
	 */
	public Collection<ConceptLabel> processSentence(Sentence sentence, List messages) {
		// long time = System.currentTimeMillis();
		// search in lexicon
		List<Concept> keys = lookupConcepts(sentence);
			
		// filter out overlapping numbers
		filterNumbers(keys);
		filterOverlap(keys);			
		
		// take out concepts that overlap with new concepts
		List<ReportConcept> reparsedConcepts = new ArrayList<ReportConcept>();
		for (ReportConcept c : concepts) {
			// if existing concept intersects this sentence
			if (intersects(c,sentence.getSpan())) {
				reparsedConcepts.add(c);
			}
		}

		// take out concepts that will be reparsed anyway
		concepts.removeAll(reparsedConcepts);

		// process phrase
		List<ConceptLabel> labels = new ArrayList<ConceptLabel>();

		for (Concept concept : keys) {
			// create new labels
			Collection<ConceptLabel> lbl = createConceptLabels(concept,sentence.getCharOffset());
			labels.addAll(lbl);

			// get entry or create it
			ReportConcept entry = createReportConcept(concept);
			entry.addLabels(lbl);

			// add to all concepts
			concepts.add(entry);
			// negatedConcepts.remove(entry);

			// process numbers
			for (ConceptLabel l : lbl)
				processNumericValues(entry, l);
		}

		// take care of negation
		negex.clear();
		negex.process(sentence, keys);
		labels.addAll(processNegation(negex, messages));

		// backup concepts so that concepts that were merged outside of parsed
		// sentence could be removed after processing
		List<ReportConcept> backup = new ArrayList<ReportConcept>(concepts);
		backup.removeAll(reparsedConcepts);
		
		// compact concepts to more specific constructs
		processConcepts(concepts);
	
		// at this point we can potentially have a situation where
		// one concept from this sentence subsumed another from the previous or next 
		// sentence
		for(ReportConcept c: backup){
			if(!concepts.contains(c))
				removedConcepts.add(c);
		}
		
		// remove dangling digits and units, cause they are likely to be junk
		removeDanglingAttributes();		
		
		// now that we may have reparsed some concepts, lets
		// see if we can retain some of the old data
		for (ReportConcept rc : reparsedConcepts) {
			// reparsed concept is in the list, then retain its data, if not
			// then it should be removed
			ReportConcept nc = TextHelper.get(concepts, rc);
			if (nc != null) {
				nc.setConceptEntry(rc.getConceptEntry());
			} else {
				removedConcepts.add(rc);
			}
		}

		// negate concepts and proces numbers
		for (ReportConcept e : negatedConcepts) {
			ReportConcept n = TextHelper.get(concepts, e);
			if (n != null) {
				n.setNegation(e.getNegation());
			}
		}

		// clear negation
		negatedConcepts.clear();

		// do eggs
		Eggs.processText(sentence.getOriginalString());
	
		// sync to interface
		sync();
		
		return labels;
	}
	
	/**
	 * remove stand-alone attributes
	 */
	private void removeDanglingAttributes(){
		// remove dangling digits and units, cause they are likely to be junk
		for(ReportConcept c: new ArrayList<ReportConcept>(concepts)){
			if(c.isAttribute())
				concepts.remove(c);
		}
	}
	
	/**
	 * try to sync concept parsing w/ report interface
	 */
	private void sync() {
		// stop sync time
 		syncTimer.stop();

		// long time = System.currentTimeMillis();

		// copy concept list
		List<ReportConcept> allConcepts = new ArrayList<ReportConcept>();
		synchronized (concepts) {
			allConcepts.addAll(concepts);
		}

		// do sync
		synchronized (removedConcepts) {
			// lets see if we can removed concepts
			// and refines
			for (ReportConcept c : removedConcepts) {
				ConceptEntry e = c.getConceptEntry();
				// if concept is not in interface, add it
				if (reportInterface.getConceptEntry(e) != null) {
					// see if removed concept was replace w/ new more
					// general/specific concept
					// if not, it is a simple remove, else it is a refine
					ReportConcept n = getRelatedConcept(c);
					if (n == null) {
						reportInterface.removeConceptEntry(e);
					} else 	if(n.isAttribute()){
						// if related concept is a left over attribute, then remove it
						concepts.remove(n);
					} else {
						// when refining, we want to retain feature information
						n.getConceptEntry().setFeature(e.getFeature());

						// now do a refine
						reportInterface.refineConceptEntry(e, n.getConceptEntry());
						allConcepts.remove(n);
						repaintConcept(n);
					}
				}
			}

			// clear removed concepts
			removedConcepts.clear();
		}

		// lets see if we can add concepts
		for (ReportConcept c : allConcepts) {
			ConceptEntry e = c.getConceptEntry();

			// if concept is not in interface, add it
			ConceptEntry o = reportInterface.getConceptEntry(e);
			if (o == null) {
				// add concept if not some stray attribute by itself
				if(!e.isAttribute())
					reportInterface.addConceptEntry(e);
			} else {
				ReportConcept or = ReportConcept.getReportConcept(o, reportInterface);
				// now lets check if negation status changed
				if ((c.isNegated() != or.isNegated())) {
					// if new concept is absent, add negation
					if (c.isNegated()) {
						reportInterface.addConceptEntry(c.getNegation().getConceptEntry());
						// otherwise remove negation
					} else if (or.isNegated()) {
						reportInterface.removeConceptEntry(or.getNegation().getConceptEntry());
					}
				}

				// such concept does exist in
				e.copyConceptStatus(o);
			}
			repaintConcept(c);
		}

		reportInterface.debug("--\nparsed concepts in document:\t" + concepts);
		reportInterface.debug();
		// System.out.println("sync time "+(System.currentTimeMillis()-time));
	}
	
	private void repaintConcept(ReportConcept c){
		if(c.getConceptEntry().getConceptStatus() != ConceptEntry.UNKNOWN)
			c.repaint();
	}
	
	/**
	 * find a related concept that is currently in the memory state
	 * 
	 * @param entry
	 * @return
	 */
	private ReportConcept getRelatedConcept(ReportConcept entry) {
		// if completly removed, no point in searching
		if(entry.getLabels().isEmpty())
			return null;
		
		for (ReportConcept c : concepts) {
			// labels in the new concept are contained within the old concept label list
			if(Collections.indexOfSubList(entry.getLabels(),c.getLabels()) > -1 || Collections.indexOfSubList(c.getLabels(),entry.getLabels()) > -1){
				//if(entry.getName().contains(c.getName()) || c.getName().contains(entry.getName())){
				return c;
			}
		}
		return null;
	}

	/**
	 * create new concept entry
	 * 
	 * @param concept
	 * @return
	 */
	private ReportConcept createReportConcept(Concept concept) {
		IClass cls = concept.getConceptClass();
		String link = null;

		// make sure concept exists
		if (cls == null) {
			cls = reportInterface.getDomainOntology().getClass(concept.getCode());
		}

		// if concept came from external source, then
		Map map = concept.getCodes();
		if (map != null && !map.isEmpty()) {
			link = "" + map.values().iterator().next();
		}

		// create concept entry
		ReportConcept r = createReportConcept(cls);

		if (link != null)
			r.setResourceLink(link);

		return r;
	}

	/**
	 * create new concept entry
	 * 
	 * @param concept
	 * @return
	 */
	private ReportConcept createReportConcept(IClass cls) {
		ConceptEntry entry = new ConceptEntry(cls.getName(), getEntryType(cls));
		return new ReportConcept(entry, reportInterface);
	}

	/**
	 * create one or more concept labels for a given concept
	 * 
	 * @param concept
	 * @return
	 */
	private Collection<ConceptLabel> createConceptLabels(Concept concept, int offset) {
		//int offset = concept.getOffset();
		List<ConceptLabel> labels = new ArrayList<ConceptLabel>();
		// add annotation the new way
		for(Annotation a: concept.getAnnotations()){
			ConceptLabel lbl = new ConceptLabel(a.getText(), offset + a.getOffset());
			lbl.setConcept(concept);
			lbl.setReportPanel(reportInterface);
			lbl.setColor(Color.black);
			labels.add(lbl);
		}
		
		
		return labels;
	}

	/**
	 * filter out duplicate numbers Ex: 1.3 might produce Number, One and Three
	 * concepts
	 * 
	 * @param text
	 * @return
	 */
	private void filterNumbers(List<Concept> concepts) {
		// make sure there are no overlaps in numbers
		Concept num = null;

		// find a general number
		for (Concept c : concepts) {
			if (c.getConceptClass() != null && NUMERIC.equals(c.getConceptClass().getName())) {
				num = c;
				break;
			}
		}

		// if there is a number
		if (num != null) {
			// get number offsets
			int num_st = num.getOffset();
			int num_en = num_st + num.getText().length();

			// search all concepts for specific numbers
			List<Concept> torem = new ArrayList<Concept>();
			for (Concept c : concepts) {
				IClass cls = c.getConceptClass();
				// if found a specific number, then
				if (cls != null && cls != num.getConceptClass() && isNumber(cls) && c.getText() != null) {
					int st = c.getOffset();
					int en = st + c.getText().length();

					// if this number is within bounds of general number, then
					// it is a repeat
					if (num_st <= st && en <= num_en) {
						torem.add(c);
						// else if the other number is within bounds of previous
						// number, then discard that
					} else if (st <= num_st && num_en <= en) {
						torem.add(num);
						num = c;
						num_st = st;
						num_en = en;
					}
				}

				// if concept text is "number", it is too general to use
				if (NUMERIC.toLowerCase().equals(c.getText()))
					torem.add(c);
			}

			// remove whatever
			for (Concept r : torem) {
				for (ListIterator<Concept> it = concepts.listIterator(); it.hasNext();) {
					Concept c = it.next();
					if (c.getText() != null && c.equals(r) && c.getText().equals(r.getText())) {
						it.remove();
						break;
					}
				}
			}

		}
	}

	/**
	 * filter out duplicate numbers Ex: 1.3 might produce Number, One and Three
	 * concepts
	 * 
	 * @param text
	 * @return
	 */
	private void filterOverlap(List<Concept> concepts) {
		// go over concepts in
		Set<Concept> torem = new HashSet<Concept>();
		Concept p = null;
		for(Concept c : concepts){
			if(p != null){
				if(c.getCode().equals(p.getCode())){
					if(c.getText() != null && c.getText().contains(p.getText())){
						torem.add(p);
					}else if(p.getText() != null && p.getText().contains(c.getText())){
						torem.add(c);
					}
				}
			}
			p = c;
		}
		
		// remove whatever
		for (Concept r : torem) {
			for (ListIterator<Concept> it = concepts.listIterator(); it.hasNext();) {
				Concept c = it.next();
				if (c.equals(r) && c.getText().equals(r.getText())) {
					it.remove();
					break;
				}
			}
		}
	}

		
	
	/**
	 * lookup concepts
	 * 
	 * @param text
	 * @return
	 */
	private List<Concept> lookupConcepts(Sentence text) {
		// search in lexicon
		List<Concept> keys = new ArrayList<Concept>();
		try {
			// check out results
			for (Concept c : reportInterface.getDomainTerminology().search(text.getOriginalString())) {
				keys.add(c);
			}

			// search for stuff in anatomic site terminology
			Terminology aterm = reportInterface.getAnatomicTerminology();
			if (aterm != null) {
				Source src = new Source(aterm.getName(), aterm.getDescription(), "" + aterm.getURI());
				for (Concept c : aterm.search(text.getOriginalString())) {
					Concept d = new Concept(getAnatomicLocationClass(c));
					d.setSearchString(c.getSearchString());
					d.setText(c.getText());
					d.setMatchedTerm(c.getMatchedTerm());
					d.setOffset(c.getOffset());
					d.setAnnotations(c.getAnnotations());
					for(Annotation a: d.getAnnotations()){
						a.setConcept(d);
					}
					
					//d.setOffset(c.getOffset() + text.getCharOffset());
					d.addCode(c.getCode(), src);
					for(int i=0;i<d.getWordMap().length;i++)
						d.getWordMap()[i] = c.getWordMap()[i];
					
					keys.add(d);
				}
			}

			// add expression lookup
			keys.addAll(lookupExpressions(text));

			// sort by offsets
			Collections.sort(keys, new Comparator<Concept>() {
				public int compare(Concept o1, Concept o2) {
					return o1.getOffset() - o2.getOffset();
				}

			});
		} catch (TerminologyException ex) {
			Config.getLogger().severe(TextHelper.getErrorMessage(ex));
		}

		return keys;
	}

	/**
	 * find closes anatomic location
	 * @param c
	 * @return
	 */
	private IClass getAnatomicLocationClass(Concept anatomicConcept) {
		IClass a = anatomicConcept.getConceptClass();
		IClass cls = reportInterface.getDomainOntology().getClass(ANATOMIC_LOCATION);
		for(IClass child: cls.getSubClasses()){
			// for every sub class, get the link to the anatomic ontology
			String link = (String) child.getPropertyValue(cls.getOntology().getProperty(HAS_CONCEPT_CODE));
			if(link != null){
				// is link valid?
				IClass b = a.getOntology().getClass(link);
				if(b != null){
					// if linked concept is the same or more general then target anatomical concept
					if(b.equals(a) || b.hasSubClass(a)){
						// replace related class with a child if what we already have
						// is not more specific still
						if(child.hasSuperClass(cls))
							cls = child;
					}
				}
			}
		}
		return cls;
	}

	/**
	 * lookup concepts
	 * 
	 * @param text
	 * @return
	 */
	private List<Concept> lookupExpressions(Sentence text) {
		List<Concept> keys = new ArrayList<Concept>();

		// check a set of hard-coded, but common expressions
		for (String expr : mergedTerms) {
			Pattern pt = Pattern.compile(expr);
			Matcher mt = pt.matcher(text.getOriginalString());
			while (mt.find()) {
				for (int i = 1; i <= mt.groupCount(); i++) {
					try {
						String txt = mt.group(i);
						for (Concept c : reportInterface.getDomainTerminology().search(txt)) {
							c.setSearchString(text.getOriginalString());
							Annotation.addAnnotation(c, txt, mt.start(i));
							keys.add(c);
						}
					} catch (TerminologyException ex) {
						Config.getLogger().severe(TextHelper.getErrorMessage(ex));
					}
				}
			}
		}

		return keys;
	}

	/**
	 * concept label is being deleted
	 * 
	 * @param lbl
	 */
	public void removeConceptLabel(ConceptLabel lbl) {
		System.out.println("removing "+lbl+" ..");
		
		lbl.setDeleted(true);
		// tokens.remove(lbl);
		// System.out.println("- "+tokens);
	}

	/**
	 * give pointer to data
	 * 
	 * public CaseEntry getCaseEntry() { return caseAuthor.getCaseEntry(); }
	 */

	// protocol button presses for worksheet
	public void actionPerformed(ActionEvent e) {
		JRadioButton button = (JRadioButton) e.getSource();
		String name = button.getText();
		int i = name.indexOf(":");
		if (i > -1) {
			if (name.startsWith("<html>"))
				name = name.substring(6, i).trim();
			else
				name = name.substring(0, i).trim();
		}
	}

	/**
	 * process numeric values in concept
	 * 
	 * @param entry
	 * @param lbl
	 */
	private void processNumericValues(ReportConcept entry, ConceptLabel lbl) {
		if (isNumber(entry.getConceptClass()) && !entry.getConceptEntry().hasNumericValue()) {
			entry.setNumericValue(TextHelper.parseDecimalValue(lbl.getText()));
		}
	}

	/**
	 * clear previousle parsed concepts
	 */
	public void clear() {
		negatedConcepts.clear();
		negex.clear();
		concepts.clear();
	}

	/**
	 * process all tokens that are in the document
	 */
	public void processDocument() {

		// compact concepts
		processConcepts(concepts);
	}

	/**
	 * process tokens and convert them to a set of concepts
	 */
	private void processConcepts(Collection<ReportConcept> concepts) {
		// compact concept list until it stops changing size
		int previousSize = 0;
		while (concepts.size() != previousSize) {
			previousSize = concepts.size();
			List<ReportConcept> list = new ArrayList<ReportConcept>(concepts);
			ReportConcept previous = list.get(0);
			for(int i=1;i<list.size();i++){
				ReportConcept entry = list.get(i);
				ReportConcept next  = ((i+1)<list.size())?list.get(i+1):null;
				
				// see if we can find a common concept for three entries
				ReportConcept common = null;
				if(next != null)
					common = mergeConcepts(previous, entry, next,concepts);
				// if no luck try merge 2 
				if(common == null)
					common = mergeConcepts(previous, entry,concepts);
				
				// if common concept found, then make it a previous concept
				if (common != null) 
					entry = common;
				previous = entry;
				
			}
		}
	}

	/**
	 * compares that a list of labels is a subset of another. 
	 * however it only compares text not offsets
	 * @param outer
	 * @param inner
	 * @return
	 */
	private boolean isSubset(List<ConceptLabel> outer, List<ConceptLabel> inner){
		for(ConceptLabel in: inner){
			boolean c = false;
			for(ConceptLabel l: outer){
				if(l.getText().equals(in.getText())){
					c = true;
					break;
				}
			}
			if(!c)
				return false;
		}
		return true;
	}
	
	/**
	 * attempt to merge two concepts
	 * 
	 * @param previous
	 * @param entry
	 * @return
	 */
	private ReportConcept mergeConcepts(ReportConcept previous, ReportConcept entry, Collection<ReportConcept> concepts){
		IClass pc = previous.getConceptClass();
		IClass ec = entry.getConceptClass();
		IClass common = getDirectCommonChild(pc,ec);
		
		// make sure that common ground is valid
		if(common != null){
			// we can't have two attributes s.a. 3 mm inferring a finding
			if(isFeature(common) && !isFeature(pc) && !isFeature(ec))
				common = null;
			// check if we are doing the same to diagnosis
			if(isDisease(common) && !isDisease(pc) && !isDisease(ec))
				common = null;
			
			// if previous concept is in fact more specific then current concept
			//TODO: this breaks depth of invasion 1.3mm
			if(pc.hasSuperClass(ec)){
				/*
				int stp = previous.getOffset();
				int enp = stp+previous.getLength();
				int stc = entry.getOffset();
				int enc = stc+entry.getLength();
				// we only accept common if more specific encompas the more general
				if(!(stp <= stc && enc <= enp)){
					common = null;
				}*/
				if(isSubset(previous.getLabels(),entry.getLabels())){
					common = null;
				}
			}else if(pc.hasSubClass(ec)){
				/*int stp = pc.getConcept().getOffset();
				int enp = stp+pc.getConcept().getText().length();
				int stc = ec.getConcept().getOffset();
				int enc = stc+ec.getConcept().getText().length();
				// we only accept common if more specific encompas the more general
				if(!(stc <= stp && enp <= enc)){
					common = null;
				}
				*/
			}
		}
		
		
		// common ground was found
		if(common != null){
			ReportConcept ne = createReportConcept(common);
			ne.addLabels(previous.getLabels());
			ne.addLabels(entry.getLabels());
			//ne.addComponent(previous);
			//ne.addComponent(entry);
			
			
			// if new concept is just an old concept
			// then retain the old concept
			if(entry.equals(ne))
				ne.setConceptEntry(entry.getConceptEntry());
			if(previous.equals(ne))
				ne.setConceptEntry(previous.getConceptEntry());
			
			
			//CORRECTION: previous should take precedence, MAX was arbitrary
			if(previous.getConceptEntry().hasNumericValue())
				ne.setNumericValue(previous.getNumericValue());
			else if(entry.getConceptEntry().hasNumericValue())
				ne.setNumericValue(entry.getNumericValue());
			
			// copy resource link
			if(previous.hasResourceLink())
				ne.setResourceLink(previous.getResourceLink());
			else if(entry.hasResourceLink())
				ne.setResourceLink(entry.getResourceLink());
			
			// copy negation
			if(previous.isNegated())
				ne.setNegation(previous.getNegation());
			else if(entry.isNegated())
				ne.setNegation(entry.getNegation());
				
			// update list
			concepts.remove(entry);
			concepts.remove(previous);
			concepts.add(ne);
		
			return ne;
		}
		return null;
	}

	/**
	 * attempt to merge two concepts
	 * 
	 * @param previous
	 * @param entry
	 * @return
	 */
	private ReportConcept mergeConcepts(ReportConcept previous, ReportConcept entry, ReportConcept next, Collection<ReportConcept> concepts){
		IClass pc = previous.getConceptClass();
		IClass ec = entry.getConceptClass();
		IClass nc = next.getConceptClass();
		IClass common = getDirectCommonChild(pc,ec,nc);
		
		// make sure that common ground is valid
		if(common != null){
			// we can't have two attributes s.a. 3 mm inferring a finding
			if(isFeature(common) && !isFeature(pc) && !isFeature(ec) && !isFeature(nc))
				common = null;
			
			// if previous concept is in fact more specific then current concept
			if(pc.hasSuperClass(ec)){
				if(isSubset(previous.getLabels(),entry.getLabels())){
					common = null;
				}
			}
		}
		
		
		// common ground was found
		if(common != null){
			ReportConcept ne = createReportConcept(common);
			ne.addLabels(previous.getLabels());
			ne.addLabels(entry.getLabels());
			ne.addLabels(next.getLabels());
				
			// if new concept is just an old concept
			// then retain the old concept
			if(entry.equals(ne))
				ne.setConceptEntry(entry.getConceptEntry());
			if(previous.equals(ne))
				ne.setConceptEntry(previous.getConceptEntry());
			if(next.equals(ne))
				ne.setConceptEntry(next.getConceptEntry());
			
			
			//CORRECTION: previous should take precedence, MAX was arbitrary
			if(previous.getConceptEntry().hasNumericValue())
				ne.setNumericValue(previous.getNumericValue());
			else if(entry.getConceptEntry().hasNumericValue())
				ne.setNumericValue(entry.getNumericValue());
			else if(next.getConceptEntry().hasNumericValue())
				ne.setNumericValue(next.getNumericValue());
			
			// copy resource link
			if(previous.hasResourceLink())
				ne.setResourceLink(previous.getResourceLink());
			else if(entry.hasResourceLink())
				ne.setResourceLink(entry.getResourceLink());
			else if(next.hasResourceLink())
				ne.setResourceLink(next.getResourceLink());
			
			// copy negation
			if(previous.isNegated())
				ne.setNegation(previous.getNegation());
			else if(entry.isNegated())
				ne.setNegation(entry.getNegation());
			else if(next.isNegated())
				ne.setNegation(next.getNegation());
				
			// update list
			concepts.remove(entry);
			concepts.remove(previous);
			concepts.remove(next);
			concepts.add(ne);
		
			return ne;
		}
		return null;
	}

	
	
	/**
	 * get common parent of two classes
	 * 
	 * @param c1
	 * @param c2
	 * @return
	 */
	private IClass getDirectCommonChild(IClass c1, IClass c2) {
		// take care of base conditions
		if (c1.equals(c2))
			return c1;

		// subsube its own children
		if (c1.hasSubClass(c2))
			return c2;
		if (c2.hasSubClass(c1))
			return c1;

		// check direct children
		List<IClass> c1c = getChildren(c1);
		List<IClass> c2c = getChildren(c2);
		List<IClass> common = new ArrayList<IClass>();
		for (IClass c : c1c) {
			if (c2c.contains(c))
				common.add(c);
		}
		if(common.isEmpty())
			return null;
		if(common.size() == 1)
			return common.get(0);
		
		// return best one, if multiple
		IClass best = null;
		for(IClass c: common){
			if(best == null)
				best = c;
			// the one with less direct superclasses wins
			else if(best.getDirectSuperClasses().length > c.getDirectSuperClasses().length)
				best = c;
		}
		return best;
	}
	
	/**
	 * get common parent of two classes
	 * 
	 * @param c1
	 * @param c2
	 * @return
	 */
	private IClass getDirectCommonChild(IClass c1, IClass c2, IClass c3) {
		// take care of base conditions
		/*
		if (c1.equals(c2))
			return c1;
		
		// subsube its own children
		if (c1.hasSubClass(c2))
			return c2;
		if (c2.hasSubClass(c1))
			return c1;
		if (c1.hasSubClass(c3))
			return c3;
		if (c2.hasSubClass(c3))
			return c3;
		*/ 
		
		
		// check direct children
		List<IClass> c1c = getChildren(c1);
		List<IClass> c2c = getChildren(c2);
		List<IClass> c3c = getChildren(c3);
		List<IClass> common = new ArrayList<IClass>();
		for (IClass c : c1c) {
			if (c2c.contains(c) && c3c.contains(c))
				common.add(c);
		}
		if(common.isEmpty())
			return null;
		if(common.size() == 1)
			return common.get(0);
		
		// return best one, if multiple
		IClass best = null;
		for(IClass c: common){
			if(best == null)
				best = c;
			// the one with less direct superclasses wins
			else if(best.getDirectSuperClasses().length > c.getDirectSuperClasses().length)
				best = c;
		}
		return best;
	}
	

	/**
	 * clever way to get children of a class
	 * 
	 * @param cls
	 * @return
	 */
	private List<IClass> getChildren(IClass cls) {
		List<IClass> subclasses = new ArrayList<IClass>();
		Collections.addAll(subclasses, cls.getDirectSubClasses());
		return subclasses;
	}

	/**
	 * highlight tokens of selected entries
	 */
	public void propertyChange(PropertyChangeEvent evt) {
		/*
		 * String prop = evt.getPropertyName();
		 * if(prop.equals(ConceptSelector.CONCEPT_SELECTED) && evt.getNewValue()
		 * != null){ ReportDocument doc =
		 * caseAuthor.getReportPanel().getReportDocument();
		 * doc.clearBackground(); ConceptEntry entry = (ConceptEntry)
		 * evt.getNewValue(); for(ConceptLabel lbl: entry.getLabels()){
		 * lbl.setBackgroundColor(Color.yellow); lbl.update(doc); } }
		 */
	}

	/**
	 * get processed concepts
	 * 
	 * @return
	 */
	public Set<ReportConcept> getProcessedConcepts() {
		return concepts;
	}

}
